# 快速入门

<cite>
**本文档中引用的文件**
- [README.md](file://README.md)
- [Cargo.toml](file://Cargo.toml)
- [src/lib.rs](file://src/lib.rs)
- [src/vcpu.rs](file://src/vcpu.rs)
</cite>

## 目录
1. [简介](#简介)
2. [前置要求](#前置要求)
3. [集成步骤](#集成步骤)
4. [基础代码示例](#基础代码示例)
5. [常见问题与解决方案](#常见问题与解决方案)

## 简介

`arm_vcpu` 是一个为 AArch64 架构设计的虚拟 CPU（vCPU）实现库，专为超虚拟化环境构建。本指南将指导您如何在项目中集成 `arm_vcpu`，涵盖从添加依赖到运行虚拟机的完整流程。

**Section sources**
- [README.md](file://README.md#L1-L10)

## 前置要求

在使用 `arm_vcpu` 之前，必须满足以下硬件和权限要求：

- **架构要求**：目标平台必须是 AArch64 架构（ARMv8-A 或更高版本）
- **权限级别**：需要 EL2（Hypervisor 模式）权限才能启用完整的虚拟化功能

这些要求确保了底层硬件支持 ARMv8 虚拟化扩展，并允许执行必要的系统寄存器操作。

**Section sources**
- [README.md](file://README.md#L54-L58)

## 集成步骤

### 1. 添加依赖

首先，在项目的 `Cargo.toml` 文件中添加 `arm_vcpu` 依赖项。

```toml
[dependencies]
arm_vcpu = "0.1"
```

该配置会引入 `arm_vcpu` 库及其所有必要依赖，包括日志、自旋锁以及 AArch64 特定的 CPU 寄存器访问模块。

**Section sources**
- [Cargo.toml](file://Cargo.toml#L1-L10)
- [README.md](file://README.md#L47-L49)

### 2. 检查硬件支持

在创建 vCPU 实例前，应调用 `has_hardware_support()` 函数检查当前平台是否支持虚拟化扩展。

此函数通过读取 `ID_AA64MMFR1_EL1` 系统寄存器来确定是否启用了虚拟化主机扩展功能。目前默认返回 `true`，但在生产环境中应根据实际硬件情况进行验证。

**Section sources**
- [src/lib.rs](file://src/lib.rs#L28-L31)

### 3. 创建 vCPU 实例

使用 `Aarch64VCpu::new()` 方法创建一个新的 vCPU 实例。该方法接受一个 `Aarch64VCpuCreateConfig` 配置对象作为参数。

配置对象包含 MPIDR_EL1 值（用于多处理器系统中的 CPU 标识）和设备树 blob 地址等关键信息。

**Section sources**
- [src/vcpu.rs](file://src/vcpu.rs#L105-L115)

### 4. 配置入口点

调用 `set_entry()` 方法设置虚拟机的启动入口地址。该地址应指向客户操作系统或固件的起始执行位置。

此方法内部会更新陷阱上下文中的异常链接寄存器（ELR），以便在进入虚拟机时正确跳转到指定地址。

**Section sources**
- [src/vcpu.rs](file://src/vcpu.rs#L148-L152)

### 5. 运行虚拟机

最后，调用 `run()` 方法启动虚拟机执行。该方法会保存主机上下文、恢复虚拟机系统寄存器，并通过底层汇编代码切换至客户模式运行。

当发生 VM-Exit 事件时（如同步异常或中断），控制权将返回给 hypervisor 进行处理。

**Section sources**
- [src/vcpu.rs](file://src/vcpu.rs#L154-L163)

## 基础代码示例

以下是一个可直接运行的基础代码片段，展示了完整的集成流程：

```rust
use arm_vcpu::{Aarch64VCpu, Aarch64VCpuCreateConfig, has_hardware_support};

// 检查硬件虚拟化是否受支持
if has_hardware_support() {
    // 创建 vCPU 配置
    let config = Aarch64VCpuCreateConfig::default();
    
    // 创建并配置虚拟 CPU
    let mut vcpu = Aarch64VCpu::new(config)?;
    
    // 设置虚拟机入口点
    vcpu.set_entry(entry_address)?;
    
    // 运行虚拟 CPU
    vcpu.run()?;
}
```

每行代码的作用已在注释中说明，遵循了从检查支持性到最终运行的逻辑顺序。

**Section sources**
- [README.md](file://README.md#L59-L67)

## 常见问题与解决方案

### 缺少必要功能（feature）

如果启用了 `"4-level-ept"` 功能，则需确保 CPU 支持至少 44 位物理地址空间。否则会在初始化时触发 panic。

**解决方案**：确认 CPU 的 PARange 值满足要求，或禁用 `"4-level-ept"` 功能以使用三级分页。

### 权限不足

未在 EL2 模式下运行会导致无法访问某些系统寄存器，从而引发异常。

**解决方案**：确保程序在 Hypervisor 模式下加载和执行，通常需要引导加载程序或现有 hypervisor 的支持。

### 中断处理冲突

`passthrough_interrupt` 配置选项与虚拟 IRQ 启用存在互斥关系。

**解决方案**：选择其一——要么启用虚拟 IRQ 并在 EL2 捕获物理 IRQ，要么禁用虚拟 IRQ 并将物理 IRQ 直接透传至 EL1。

**Section sources**
- [src/vcpu.rs](file://src/vcpu.rs#L240-L250)